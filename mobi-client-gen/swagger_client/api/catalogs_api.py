# coding: utf-8

"""
    Mobi

    Mobi REST API Documentation  # noqa: E501

    OpenAPI spec version: 1.22.0-SNAPSHOT
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class CatalogsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_branch(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a Branch for a VersionedRDFRecord identified by the IDs using the passed form data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_branch(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str type:
        :param str title:
        :param str description:
        :param str commit_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_branch_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_branch_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def create_branch_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a Branch for a VersionedRDFRecord identified by the IDs using the passed form data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_branch_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str type:
        :param str title:
        :param str description:
        :param str commit_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'type', 'title', 'description', 'commit_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_branch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_branch`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `create_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'type' in params:
            form_params.append(('type', params['type']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'description' in params:
            form_params.append(('description', params['description']))  # noqa: E501
        if 'commit_id' in params:
            form_params.append(('commitId', params['commit_id']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_branch_commit(self, catalog_id, record_id, branch_id, message, **kwargs):  # noqa: E501
        """Creates a new Commit in the repository for a specific Branch using the InProgressCommit associated with the user making this request. The HEAD Commit is updated to be this new Commit  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_branch_commit(catalog_id, record_id, branch_id, message, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str message: Message for the new Commit (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_branch_commit_with_http_info(catalog_id, record_id, branch_id, message, **kwargs)  # noqa: E501
        else:
            (data) = self.create_branch_commit_with_http_info(catalog_id, record_id, branch_id, message, **kwargs)  # noqa: E501
            return data

    def create_branch_commit_with_http_info(self, catalog_id, record_id, branch_id, message, **kwargs):  # noqa: E501
        """Creates a new Commit in the repository for a specific Branch using the InProgressCommit associated with the user making this request. The HEAD Commit is updated to be this new Commit  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_branch_commit_with_http_info(catalog_id, record_id, branch_id, message, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str message: Message for the new Commit (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id', 'message']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_branch_commit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_branch_commit`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `create_branch_commit`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `create_branch_commit`")  # noqa: E501
        # verify the required parameter 'message' is set
        if ('message' not in params or
                params['message'] is None):
            raise ValueError("Missing the required parameter `message` when calling `create_branch_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []
        if 'message' in params:
            query_params.append(('message', params['message']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/commits', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_in_progress_commit(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a InProgressCommit linked to a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_in_progress_commit(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def create_in_progress_commit_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a InProgressCommit linked to a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_in_progress_commit_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_in_progress_commit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_in_progress_commit`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `create_in_progress_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/in-progress-commit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_record(self, catalog_id, **kwargs):  # noqa: E501
        """Creates a new Record in the Catalog  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_record(catalog_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: (required)
        :param str type:
        :param str title:
        :param str identifier:
        :param str description:
        :param str markdown:
        :param list[str] keywords:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_record_with_http_info(catalog_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_record_with_http_info(catalog_id, **kwargs)  # noqa: E501
            return data

    def create_record_with_http_info(self, catalog_id, **kwargs):  # noqa: E501
        """Creates a new Record in the Catalog  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_record_with_http_info(catalog_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: (required)
        :param str type:
        :param str title:
        :param str identifier:
        :param str description:
        :param str markdown:
        :param list[str] keywords:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'type', 'title', 'identifier', 'description', 'markdown', 'keywords']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'type' in params:
            form_params.append(('type', params['type']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'identifier' in params:
            form_params.append(('identifier', params['identifier']))  # noqa: E501
        if 'description' in params:
            form_params.append(('description', params['description']))  # noqa: E501
        if 'markdown' in params:
            form_params.append(('markdown', params['markdown']))  # noqa: E501
        if 'keywords' in params:
            form_params.append(('keywords', params['keywords']))  # noqa: E501
            collection_formats['keywords'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tag(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a Tag for the identified VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tag(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str title:
        :param str description:
        :param str iri:
        :param str commit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_tag_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_tag_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def create_tag_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a Tag for the identified VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tag_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str title:
        :param str description:
        :param str iri:
        :param str commit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'title', 'description', 'iri', 'commit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_tag`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `create_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'description' in params:
            form_params.append(('description', params['description']))  # noqa: E501
        if 'iri' in params:
            form_params.append(('iri', params['iri']))  # noqa: E501
        if 'commit' in params:
            form_params.append(('commit', params['commit']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_unversioned_distribution(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a new Distribution for the provided UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_unversioned_distribution(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str title:
        :param str description:
        :param str format:
        :param str access_url:
        :param str download_url:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_unversioned_distribution_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_unversioned_distribution_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def create_unversioned_distribution_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a new Distribution for the provided UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_unversioned_distribution_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str title:
        :param str description:
        :param str format:
        :param str access_url:
        :param str download_url:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'title', 'description', 'format', 'access_url', 'download_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_unversioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `create_unversioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'description' in params:
            form_params.append(('description', params['description']))  # noqa: E501
        if 'format' in params:
            form_params.append(('format', params['format']))  # noqa: E501
        if 'access_url' in params:
            form_params.append(('accessURL', params['access_url']))  # noqa: E501
        if 'download_url' in params:
            form_params.append(('downloadURL', params['download_url']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/distributions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_version(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a Version for the identified VersionedRecord using the passed form data and stores it in the repository. This Version will become the latest Version for the identified VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_version(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str type:
        :param str title:
        :param str description:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_version_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_version_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def create_version_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Creates a Version for the identified VersionedRecord using the passed form data and stores it in the repository. This Version will become the latest Version for the identified VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_version_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str type:
        :param str title:
        :param str description:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'type', 'title', 'description']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_version`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `create_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'type' in params:
            form_params.append(('type', params['type']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'description' in params:
            form_params.append(('description', params['description']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_versioned_distribution(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Creates a Distribution for the identified Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_versioned_distribution(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str title:
        :param str description:
        :param str format:
        :param str access_url:
        :param str download_url:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_versioned_distribution_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_versioned_distribution_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
            return data

    def create_versioned_distribution_with_http_info(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Creates a Distribution for the identified Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_versioned_distribution_with_http_info(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str title:
        :param str description:
        :param str format:
        :param str access_url:
        :param str download_url:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'version_id', 'title', 'description', 'format', 'access_url', 'download_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_versioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `create_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `create_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `create_versioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'description' in params:
            form_params.append(('description', params['description']))  # noqa: E501
        if 'format' in params:
            form_params.append(('format', params['format']))  # noqa: E501
        if 'access_url' in params:
            form_params.append(('accessURL', params['access_url']))  # noqa: E501
        if 'download_url' in params:
            form_params.append(('downloadURL', params['download_url']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/distributions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_branch(self, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Deletes a specific Branch for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_branch(catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_branch_with_http_info(catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_branch_with_http_info(catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
            return data

    def delete_branch_with_http_info(self, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Deletes a specific Branch for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_branch_with_http_info(catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_branch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `delete_branch`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `delete_branch`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `delete_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_in_progress_commit(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Deletes the changes made in the User's current InProgressCommit for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_in_progress_commit(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def delete_in_progress_commit_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Deletes the changes made in the User's current InProgressCommit for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_in_progress_commit_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_in_progress_commit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `delete_in_progress_commit`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `delete_in_progress_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/in-progress-commit', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_record(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Deletes the Catalog Record by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_record(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the Record ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_record_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_record_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def delete_record_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Deletes the Catalog Record by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_record_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the Record ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `delete_record`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `delete_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_unversioned_distribution(self, catalog_id, record_id, distribution_id, **kwargs):  # noqa: E501
        """Deletes a specific Distribution of an UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_unversioned_distribution(catalog_id, record_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_unversioned_distribution_with_http_info(catalog_id, record_id, distribution_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_unversioned_distribution_with_http_info(catalog_id, record_id, distribution_id, **kwargs)  # noqa: E501
            return data

    def delete_unversioned_distribution_with_http_info(self, catalog_id, record_id, distribution_id, **kwargs):  # noqa: E501
        """Deletes a specific Distribution of an UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_unversioned_distribution_with_http_info(catalog_id, record_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'distribution_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_unversioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `delete_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `delete_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'distribution_id' is set
        if ('distribution_id' not in params or
                params['distribution_id'] is None):
            raise ValueError("Missing the required parameter `distribution_id` when calling `delete_unversioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'distribution_id' in params:
            path_params['distributionId'] = params['distribution_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/distributions/{distributionId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_version(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Removes a specific Version from a VersionedRecord. If that Version happens to be the latest Version, the latest Version will be updated to be the previous Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_version(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the VersionedRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_version_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_version_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
            return data

    def delete_version_with_http_info(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Removes a specific Version from a VersionedRecord. If that Version happens to be the latest Version, the latest Version will be updated to be the previous Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_version_with_http_info(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the VersionedRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `delete_version`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `delete_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_versioned_distribution(self, catalog_id, record_id, version_id, distribution_id, **kwargs):  # noqa: E501
        """Deletes a specific Distribution of the identified Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_versioned_distribution(catalog_id, record_id, version_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_versioned_distribution_with_http_info(catalog_id, record_id, version_id, distribution_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_versioned_distribution_with_http_info(catalog_id, record_id, version_id, distribution_id, **kwargs)  # noqa: E501
            return data

    def delete_versioned_distribution_with_http_info(self, catalog_id, record_id, version_id, distribution_id, **kwargs):  # noqa: E501
        """Deletes a specific Distribution of the identified Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_versioned_distribution_with_http_info(catalog_id, record_id, version_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'version_id', 'distribution_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_versioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `delete_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `delete_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'distribution_id' is set
        if ('distribution_id' not in params or
                params['distribution_id'] is None):
            raise ValueError("Missing the required parameter `distribution_id` when calling `delete_versioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501
        if 'distribution_id' in params:
            path_params['distributionId'] = params['distribution_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/distributions/{distributionId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_branch(self, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Get a specific Branch for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branch(catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_branch_with_http_info(catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_branch_with_http_info(catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
            return data

    def get_branch_with_http_info(self, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Get a specific Branch for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branch_with_http_info(catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_branch`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_branch`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `get_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_branch_commit(self, catalog_id, record_id, branch_id, commit_id, **kwargs):  # noqa: E501
        """Gets the Commit identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branch_commit(catalog_id, record_id, branch_id, commit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str commit_id: String representing the Commit ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_branch_commit_with_http_info(catalog_id, record_id, branch_id, commit_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_branch_commit_with_http_info(catalog_id, record_id, branch_id, commit_id, **kwargs)  # noqa: E501
            return data

    def get_branch_commit_with_http_info(self, catalog_id, record_id, branch_id, commit_id, **kwargs):  # noqa: E501
        """Gets the Commit identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branch_commit_with_http_info(catalog_id, record_id, branch_id, commit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str commit_id: String representing the Commit ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id', 'commit_id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branch_commit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_branch_commit`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_branch_commit`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `get_branch_commit`")  # noqa: E501
        # verify the required parameter 'commit_id' is set
        if ('commit_id' not in params or
                params['commit_id'] is None):
            raise ValueError("Missing the required parameter `commit_id` when calling `get_branch_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501
        if 'commit_id' in params:
            path_params['commitId'] = params['commit_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/commits/{commitId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_branches(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets a list of Branches associated with a VersionedRDFRecord identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branches(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str sort: Field with sort order specified
        :param int offset: Offset for the page
        :param int limit: Number of Branches to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :param bool apply_user_filter: Whether or not the list should be filtered to Branches associated with the user making the request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_branches_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_branches_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def get_branches_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets a list of Branches associated with a VersionedRDFRecord identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branches_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str sort: Field with sort order specified
        :param int offset: Offset for the page
        :param int limit: Number of Branches to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :param bool apply_user_filter: Whether or not the list should be filtered to Branches associated with the user making the request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'sort', 'offset', 'limit', 'ascending', 'apply_user_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_branches`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_branches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'apply_user_filter' in params:
            query_params.append(('applyUserFilter', params['apply_user_filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_catalog(self, catalog_id, **kwargs):  # noqa: E501
        """Retrieves the Catalog specified by the provided ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_catalog(catalog_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :return: JsonLdObject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_catalog_with_http_info(catalog_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_catalog_with_http_info(catalog_id, **kwargs)  # noqa: E501
            return data

    def get_catalog_with_http_info(self, catalog_id, **kwargs):  # noqa: E501
        """Retrieves the Catalog specified by the provided ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_catalog_with_http_info(catalog_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :return: JsonLdObject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_catalog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_catalog`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonLdObject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_catalogs(self, **kwargs):  # noqa: E501
        """Retrieves the distributed and local Catalogs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_catalogs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Optional Type of Catalog you want back (local or distributed)
        :return: JsonLdObjects
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_catalogs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_catalogs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_catalogs_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the distributed and local Catalogs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_catalogs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Optional Type of Catalog you want back (local or distributed)
        :return: JsonLdObjects
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_catalogs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonLdObjects',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_commit_chain(self, catalog_id, record_id, branch_id, target_id, **kwargs):  # noqa: E501
        """Gets a list of Commits associated with the Branch identified by the provided IDs which represents the Commit chain for that Branch. If a limit is passed which is greater than zero, will paginate the results. If a targetId is passed, then only commits between the HEAD commits of the branchId and targetId will be returned.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_commit_chain(catalog_id, record_id, branch_id, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str target_id: String representing the target Branch ID (required)
        :param int offset: Optional offset for the results
        :param int limit: Optional limit for the results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_commit_chain_with_http_info(catalog_id, record_id, branch_id, target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_commit_chain_with_http_info(catalog_id, record_id, branch_id, target_id, **kwargs)  # noqa: E501
            return data

    def get_commit_chain_with_http_info(self, catalog_id, record_id, branch_id, target_id, **kwargs):  # noqa: E501
        """Gets a list of Commits associated with the Branch identified by the provided IDs which represents the Commit chain for that Branch. If a limit is passed which is greater than zero, will paginate the results. If a targetId is passed, then only commits between the HEAD commits of the branchId and targetId will be returned.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_commit_chain_with_http_info(catalog_id, record_id, branch_id, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str target_id: String representing the target Branch ID (required)
        :param int offset: Optional offset for the results
        :param int limit: Optional limit for the results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id', 'target_id', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_commit_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_commit_chain`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_commit_chain`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `get_commit_chain`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_commit_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []
        if 'target_id' in params:
            query_params.append(('targetId', params['target_id']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/commits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_compiled_resource(self, catalog_id, record_id, branch_id, commit_id, **kwargs):  # noqa: E501
        """Gets the Commit identified by the provided IDs and returns the compiled Resource following the Commit chain which terminates at the identified Commit  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compiled_resource(catalog_id, record_id, branch_id, commit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str commit_id: String representing the Commit ID (required)
        :param str format: Optional RDF return format
        :param bool apply_in_progress_commit: Boolean value identifying whether the InProgressCommit associated with identified Record should be  applied to the result
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_compiled_resource_with_http_info(catalog_id, record_id, branch_id, commit_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_compiled_resource_with_http_info(catalog_id, record_id, branch_id, commit_id, **kwargs)  # noqa: E501
            return data

    def get_compiled_resource_with_http_info(self, catalog_id, record_id, branch_id, commit_id, **kwargs):  # noqa: E501
        """Gets the Commit identified by the provided IDs and returns the compiled Resource following the Commit chain which terminates at the identified Commit  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compiled_resource_with_http_info(catalog_id, record_id, branch_id, commit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str commit_id: String representing the Commit ID (required)
        :param str format: Optional RDF return format
        :param bool apply_in_progress_commit: Boolean value identifying whether the InProgressCommit associated with identified Record should be  applied to the result
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id', 'commit_id', 'format', 'apply_in_progress_commit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compiled_resource" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_compiled_resource`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_compiled_resource`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `get_compiled_resource`")  # noqa: E501
        # verify the required parameter 'commit_id' is set
        if ('commit_id' not in params or
                params['commit_id'] is None):
            raise ValueError("Missing the required parameter `commit_id` when calling `get_compiled_resource`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501
        if 'commit_id' in params:
            path_params['commitId'] = params['commit_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'apply_in_progress_commit' in params:
            query_params.append(('applyInProgressCommit', params['apply_in_progress_commit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/commits/{commitId}/resource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_conflicts(self, catalog_id, record_id, branch_id, target_id, **kwargs):  # noqa: E501
        """Gets the Conflicts between the HEAD Commit of the Branch identified by the provided IDs in the path and the HEAD Commit of the Branch identified by the query parameter. For this comparison to be done, the Commits must have an ancestor Commit in common  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conflicts(catalog_id, record_id, branch_id, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the VersionedRDFRecord ID (required)
        :param str target_id: String representing the target Branch ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_conflicts_with_http_info(catalog_id, record_id, branch_id, target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_conflicts_with_http_info(catalog_id, record_id, branch_id, target_id, **kwargs)  # noqa: E501
            return data

    def get_conflicts_with_http_info(self, catalog_id, record_id, branch_id, target_id, **kwargs):  # noqa: E501
        """Gets the Conflicts between the HEAD Commit of the Branch identified by the provided IDs in the path and the HEAD Commit of the Branch identified by the query parameter. For this comparison to be done, the Commits must have an ancestor Commit in common  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conflicts_with_http_info(catalog_id, record_id, branch_id, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the VersionedRDFRecord ID (required)
        :param str target_id: String representing the target Branch ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id', 'target_id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_conflicts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_conflicts`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_conflicts`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `get_conflicts`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_conflicts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []
        if 'target_id' in params:
            query_params.append(('targetId', params['target_id']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/conflicts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_difference(self, catalog_id, record_id, branch_id, target_id, **kwargs):  # noqa: E501
        """Gets the Difference between the HEAD Commit of the Branch identified by the provided IDs in the path and the HEAD Commit of the Branch identified by the query parameter. For this comparison to be done, the Commits must have an ancestor Commit in common.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_difference(catalog_id, record_id, branch_id, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the source Branch ID (required)
        :param str target_id: String representing the target Branch ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_difference_with_http_info(catalog_id, record_id, branch_id, target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_difference_with_http_info(catalog_id, record_id, branch_id, target_id, **kwargs)  # noqa: E501
            return data

    def get_difference_with_http_info(self, catalog_id, record_id, branch_id, target_id, **kwargs):  # noqa: E501
        """Gets the Difference between the HEAD Commit of the Branch identified by the provided IDs in the path and the HEAD Commit of the Branch identified by the query parameter. For this comparison to be done, the Commits must have an ancestor Commit in common.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_difference_with_http_info(catalog_id, record_id, branch_id, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the source Branch ID (required)
        :param str target_id: String representing the target Branch ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id', 'target_id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_difference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_difference`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_difference`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `get_difference`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_difference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []
        if 'target_id' in params:
            query_params.append(('targetId', params['target_id']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/difference', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_head(self, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Gets the HEAD Commit for a specific Branch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_head(catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_head_with_http_info(catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_head_with_http_info(catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
            return data

    def get_head_with_http_info(self, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Gets the HEAD Commit for a specific Branch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_head_with_http_info(catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the Branch ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'branch_id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_head" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_head`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_head`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `get_head`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/commits/head', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_in_progress_commit(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets the changes made in the User's current InProgressCommit for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_in_progress_commit(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def get_in_progress_commit_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets the changes made in the User's current InProgressCommit for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_in_progress_commit_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str format: Optional RDF return format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_in_progress_commit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_in_progress_commit`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_in_progress_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/in-progress-commit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_keywords(self, catalog_id, offset, limit, **kwargs):  # noqa: E501
        """Retrieves the Keywords in the Catalog  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_keywords(catalog_id, offset, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param int offset: Offset for the page (required)
        :param int limit: Number of Keywords to return in one page (required)
        :param str search_text: String used to filter out Keywords
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_keywords_with_http_info(catalog_id, offset, limit, **kwargs)  # noqa: E501
        else:
            (data) = self.get_keywords_with_http_info(catalog_id, offset, limit, **kwargs)  # noqa: E501
            return data

    def get_keywords_with_http_info(self, catalog_id, offset, limit, **kwargs):  # noqa: E501
        """Retrieves the Keywords in the Catalog  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_keywords_with_http_info(catalog_id, offset, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param int offset: Offset for the page (required)
        :param int limit: Number of Keywords to return in one page (required)
        :param str search_text: String used to filter out Keywords
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'offset', 'limit', 'search_text']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_keywords" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_keywords`")  # noqa: E501
        # verify the required parameter 'offset' is set
        if ('offset' not in params or
                params['offset'] is None):
            raise ValueError("Missing the required parameter `offset` when calling `get_keywords`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if ('limit' not in params or
                params['limit'] is None):
            raise ValueError("Missing the required parameter `limit` when calling `get_keywords`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501

        query_params = []
        if 'search_text' in params:
            query_params.append(('searchText', params['search_text']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/keywords', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_latest_version(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets the latest Version of a VersionedRecord identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_latest_version(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_latest_version_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_latest_version_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def get_latest_version_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets the latest Version of a VersionedRecord identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_latest_version_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_latest_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_latest_version`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_latest_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_master_branch(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets the master Branch of a VersionedRDFRecord identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_master_branch(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_master_branch_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_master_branch_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def get_master_branch_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Gets the master Branch of a VersionedRDFRecord identified by the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_master_branch_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_master_branch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_master_branch`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_master_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/master', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_record(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Retrieves the Catalog record by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_record(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the Record ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_record_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_record_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def get_record_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Retrieves the Catalog record by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_record_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the Record ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_record`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_record_types(self, **kwargs):  # noqa: E501
        """Retrieves all the available record types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_record_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: IRIs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_record_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_record_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_record_types_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves all the available record types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_record_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: IRIs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_record_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/record-types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IRIs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_records(self, catalog_id, offset, limit, search_text, **kwargs):  # noqa: E501
        """Retrieves the Records in the Catalog  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_records(catalog_id, offset, limit, search_text, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param int offset: Offset for the page (required)
        :param int limit: Number of Records to return in one page (required)
        :param str search_text: String used to filter out Records (required)
        :param str sort:
        :param str type:
        :param list[str] keywords: List of keywords
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_records_with_http_info(catalog_id, offset, limit, search_text, **kwargs)  # noqa: E501
        else:
            (data) = self.get_records_with_http_info(catalog_id, offset, limit, search_text, **kwargs)  # noqa: E501
            return data

    def get_records_with_http_info(self, catalog_id, offset, limit, search_text, **kwargs):  # noqa: E501
        """Retrieves the Records in the Catalog  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_records_with_http_info(catalog_id, offset, limit, search_text, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param int offset: Offset for the page (required)
        :param int limit: Number of Records to return in one page (required)
        :param str search_text: String used to filter out Records (required)
        :param str sort:
        :param str type:
        :param list[str] keywords: List of keywords
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'offset', 'limit', 'search_text', 'sort', 'type', 'keywords', 'ascending']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_records" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_records`")  # noqa: E501
        # verify the required parameter 'offset' is set
        if ('offset' not in params or
                params['offset'] is None):
            raise ValueError("Missing the required parameter `offset` when calling `get_records`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if ('limit' not in params or
                params['limit'] is None):
            raise ValueError("Missing the required parameter `limit` when calling `get_records`")  # noqa: E501
        # verify the required parameter 'search_text' is set
        if ('search_text' not in params or
                params['search_text'] is None):
            raise ValueError("Missing the required parameter `search_text` when calling `get_records`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
            collection_formats['keywords'] = 'multi'  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'search_text' in params:
            query_params.append(('searchText', params['search_text']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sort_options(self, **kwargs):  # noqa: E501
        """Retrieves all the available sorting options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sort_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: IRIs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sort_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_sort_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_sort_options_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves all the available sorting options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sort_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: IRIs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sort_options" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/sort-options', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IRIs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unversioned_distribution(self, catalog_id, record_id, distribution_id, **kwargs):  # noqa: E501
        """Gets a specific Distribution of an UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unversioned_distribution(catalog_id, record_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unversioned_distribution_with_http_info(catalog_id, record_id, distribution_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_unversioned_distribution_with_http_info(catalog_id, record_id, distribution_id, **kwargs)  # noqa: E501
            return data

    def get_unversioned_distribution_with_http_info(self, catalog_id, record_id, distribution_id, **kwargs):  # noqa: E501
        """Gets a specific Distribution of an UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unversioned_distribution_with_http_info(catalog_id, record_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'distribution_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unversioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'distribution_id' is set
        if ('distribution_id' not in params or
                params['distribution_id'] is None):
            raise ValueError("Missing the required parameter `distribution_id` when calling `get_unversioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'distribution_id' in params:
            path_params['distributionId'] = params['distribution_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/distributions/{distributionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unversioned_distributions(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Retrieves the list of Distributions associated with an UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unversioned_distributions(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str sort:
        :param int offset: Offset for the page
        :param int limit: Number of Distributions to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unversioned_distributions_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_unversioned_distributions_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def get_unversioned_distributions_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Retrieves the list of Distributions associated with an UnversionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unversioned_distributions_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str sort:
        :param int offset: Offset for the page
        :param int limit: Number of Distributions to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'sort', 'offset', 'limit', 'ascending']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unversioned_distributions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_unversioned_distributions`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_unversioned_distributions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/distributions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_version(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Gets a specific Version for the identified VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the VersionedRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_version_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_version_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_version_with_http_info(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Gets a specific Version for the identified VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_with_http_info(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the VersionedRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_version`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_version_commit(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Gets the Commit associated with the identified Version using the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_commit(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str format: Optional format string
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_version_commit_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_version_commit_with_http_info(catalog_id, record_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_version_commit_with_http_info(self, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Gets the Commit associated with the identified Version using the provided IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_commit_with_http_info(catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str format: Optional format string
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'version_id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version_commit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_version_commit`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_version_commit`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_version_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/commit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_versioned_distribution(self, catalog_id, record_id, version_id, distribution_id, **kwargs):  # noqa: E501
        """Gets a specific Distribution for the Version identified by the IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versioned_distribution(catalog_id, record_id, version_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_versioned_distribution_with_http_info(catalog_id, record_id, version_id, distribution_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_versioned_distribution_with_http_info(catalog_id, record_id, version_id, distribution_id, **kwargs)  # noqa: E501
            return data

    def get_versioned_distribution_with_http_info(self, catalog_id, record_id, version_id, distribution_id, **kwargs):  # noqa: E501
        """Gets a specific Distribution for the Version identified by the IDs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versioned_distribution_with_http_info(catalog_id, record_id, version_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'version_id', 'distribution_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_versioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'distribution_id' is set
        if ('distribution_id' not in params or
                params['distribution_id'] is None):
            raise ValueError("Missing the required parameter `distribution_id` when calling `get_versioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501
        if 'distribution_id' in params:
            path_params['distributionId'] = params['distribution_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/distributions/{distributionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_versioned_distributions(self, catalog_id, record_id, version_id, sort, **kwargs):  # noqa: E501
        """Gets the list of all Distributions for the identified Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versioned_distributions(catalog_id, record_id, version_id, sort, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str sort: Field with sort order specified (required)
        :param int offset: Offset for the page
        :param int limit: Number of Distributions to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_versioned_distributions_with_http_info(catalog_id, record_id, version_id, sort, **kwargs)  # noqa: E501
        else:
            (data) = self.get_versioned_distributions_with_http_info(catalog_id, record_id, version_id, sort, **kwargs)  # noqa: E501
            return data

    def get_versioned_distributions_with_http_info(self, catalog_id, record_id, version_id, sort, **kwargs):  # noqa: E501
        """Gets the list of all Distributions for the identified Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versioned_distributions_with_http_info(catalog_id, record_id, version_id, sort, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str sort: Field with sort order specified (required)
        :param int offset: Offset for the page
        :param int limit: Number of Distributions to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'version_id', 'sort', 'offset', 'limit', 'ascending']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_versioned_distributions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_versioned_distributions`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_versioned_distributions`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_versioned_distributions`")  # noqa: E501
        # verify the required parameter 'sort' is set
        if ('sort' not in params or
                params['sort'] is None):
            raise ValueError("Missing the required parameter `sort` when calling `get_versioned_distributions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/distributions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_versions(self, catalog_id, record_id, sort, **kwargs):  # noqa: E501
        """Gets a list of Versions for a VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versions(catalog_id, record_id, sort, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str sort: Field with sort order specified (required)
        :param int offset: Offset for the page
        :param int limit: Number of Versions to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_versions_with_http_info(catalog_id, record_id, sort, **kwargs)  # noqa: E501
        else:
            (data) = self.get_versions_with_http_info(catalog_id, record_id, sort, **kwargs)  # noqa: E501
            return data

    def get_versions_with_http_info(self, catalog_id, record_id, sort, **kwargs):  # noqa: E501
        """Gets a list of Versions for a VersionedRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versions_with_http_info(catalog_id, record_id, sort, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str sort: Field with sort order specified (required)
        :param int offset: Offset for the page
        :param int limit: Number of Versions to return in one page
        :param bool ascending: Whether or not the list should be sorted ascending or descending
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'sort', 'offset', 'limit', 'ascending']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `get_versions`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_versions`")  # noqa: E501
        # verify the required parameter 'sort' is set
        if ('sort' not in params or
                params['sort'] is None):
            raise ValueError("Missing the required parameter `sort` when calling `get_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def merge(self, target_id, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Performs a merge between the two Branches identified by the provided IDs. The addition and deletion statements that are required to resolve any conflicts will be used to create the merged Commit. The target Branch will point to the new merge commit, but the source Branch  will still point to the original head commit.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge(target_id, catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: Target Branch IRI (required)
        :param str catalog_id: Catalog IRI (required)
        :param str record_id: VersionedRecord IRI (required)
        :param str branch_id: Source Branch IRI (required)
        :param str additions:
        :param str deletions:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.merge_with_http_info(target_id, catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.merge_with_http_info(target_id, catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
            return data

    def merge_with_http_info(self, target_id, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Performs a merge between the two Branches identified by the provided IDs. The addition and deletion statements that are required to resolve any conflicts will be used to create the merged Commit. The target Branch will point to the new merge commit, but the source Branch  will still point to the original head commit.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge_with_http_info(target_id, catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: Target Branch IRI (required)
        :param str catalog_id: Catalog IRI (required)
        :param str record_id: VersionedRecord IRI (required)
        :param str branch_id: Source Branch IRI (required)
        :param str additions:
        :param str deletions:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'catalog_id', 'record_id', 'branch_id', 'additions', 'deletions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method merge" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `merge`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `merge`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `merge`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `merge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []
        if 'target_id' in params:
            query_params.append(('targetId', params['target_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'additions' in params:
            form_params.append(('additions', params['additions']))  # noqa: E501
        if 'deletions' in params:
            form_params.append(('deletions', params['deletions']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}/conflicts/resolution', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_branch(self, body, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Updates the specified Branch using the modifications in the provided newBranch for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_branch(body, catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: String representing the Branch ID (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_branch_with_http_info(body, catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_branch_with_http_info(body, catalog_id, record_id, branch_id, **kwargs)  # noqa: E501
            return data

    def update_branch_with_http_info(self, body, catalog_id, record_id, branch_id, **kwargs):  # noqa: E501
        """Updates the specified Branch using the modifications in the provided newBranch for a specific VersionedRDFRecord  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_branch_with_http_info(body, catalog_id, record_id, branch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: String representing the Branch ID (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str branch_id: String representing the VersionedRDFRecord ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'catalog_id', 'record_id', 'branch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_branch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_branch`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `update_branch`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `update_branch`")  # noqa: E501
        # verify the required parameter 'branch_id' is set
        if ('branch_id' not in params or
                params['branch_id'] is None):
            raise ValueError("Missing the required parameter `branch_id` when calling `update_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'branch_id' in params:
            path_params['branchId'] = params['branch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/branches/{branchId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_in_progress_commit(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Updates the InProgressCommit for a user identified by the provided IDs using the statements found in the provided form data. If the user does not have an InProgressCommit, one will be created with the provided data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_in_progress_commit(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str additions:
        :param str deletions:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_in_progress_commit_with_http_info(catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def update_in_progress_commit_with_http_info(self, catalog_id, record_id, **kwargs):  # noqa: E501
        """Updates the InProgressCommit for a user identified by the provided IDs using the statements found in the provided form data. If the user does not have an InProgressCommit, one will be created with the provided data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_in_progress_commit_with_http_info(catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str additions:
        :param str deletions:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catalog_id', 'record_id', 'additions', 'deletions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_in_progress_commit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `update_in_progress_commit`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `update_in_progress_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'additions' in params:
            form_params.append(('additions', params['additions']))  # noqa: E501
        if 'deletions' in params:
            form_params.append(('deletions', params['deletions']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/in-progress-commit', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_record(self, body, catalog_id, record_id, **kwargs):  # noqa: E501
        """Updates the Catalog Record by its ID using the provided Record JSON-LD   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_record(body, catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Record which will replace the existing Record (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the Record ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_record_with_http_info(body, catalog_id, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_record_with_http_info(body, catalog_id, record_id, **kwargs)  # noqa: E501
            return data

    def update_record_with_http_info(self, body, catalog_id, record_id, **kwargs):  # noqa: E501
        """Updates the Catalog Record by its ID using the provided Record JSON-LD   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_record_with_http_info(body, catalog_id, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Record which will replace the existing Record (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the Record ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'catalog_id', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_record`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `update_record`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `update_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_unversioned_distribution(self, body, catalog_id, record_id, distribution_id, **kwargs):  # noqa: E501
        """Updates a specific Distribution for an UnversionedRecord identified by the provided IDs using the modifications in the provided JSON-LD  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_unversioned_distribution(body, catalog_id, record_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Distribution which will replace the existing Distribution (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_unversioned_distribution_with_http_info(body, catalog_id, record_id, distribution_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_unversioned_distribution_with_http_info(body, catalog_id, record_id, distribution_id, **kwargs)  # noqa: E501
            return data

    def update_unversioned_distribution_with_http_info(self, body, catalog_id, record_id, distribution_id, **kwargs):  # noqa: E501
        """Updates a specific Distribution for an UnversionedRecord identified by the provided IDs using the modifications in the provided JSON-LD  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_unversioned_distribution_with_http_info(body, catalog_id, record_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Distribution which will replace the existing Distribution (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the UnversionedRecord ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'catalog_id', 'record_id', 'distribution_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_unversioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `update_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `update_unversioned_distribution`")  # noqa: E501
        # verify the required parameter 'distribution_id' is set
        if ('distribution_id' not in params or
                params['distribution_id'] is None):
            raise ValueError("Missing the required parameter `distribution_id` when calling `update_unversioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'distribution_id' in params:
            path_params['distributionId'] = params['distribution_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/distributions/{distributionId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_version(self, body, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Updates the Version identified by the provided IDs using the modifications in the provided JSON-LD  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_version(body, catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Version which will replace the existing Version (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_version_with_http_info(body, catalog_id, record_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_version_with_http_info(body, catalog_id, record_id, version_id, **kwargs)  # noqa: E501
            return data

    def update_version_with_http_info(self, body, catalog_id, record_id, version_id, **kwargs):  # noqa: E501
        """Updates the Version identified by the provided IDs using the modifications in the provided JSON-LD  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_version_with_http_info(body, catalog_id, record_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Version which will replace the existing Version (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'catalog_id', 'record_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_version`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `update_version`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `update_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `update_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_versioned_distribution(self, body, catalog_id, record_id, version_id, distribution_id, **kwargs):  # noqa: E501
        """Updates a specific Distribution of the identified Version with the modifications in the provided newDistribution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_versioned_distribution(body, catalog_id, record_id, version_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Distribution which will replace the existing Distribution (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_versioned_distribution_with_http_info(body, catalog_id, record_id, version_id, distribution_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_versioned_distribution_with_http_info(body, catalog_id, record_id, version_id, distribution_id, **kwargs)  # noqa: E501
            return data

    def update_versioned_distribution_with_http_info(self, body, catalog_id, record_id, version_id, distribution_id, **kwargs):  # noqa: E501
        """Updates a specific Distribution of the identified Version with the modifications in the provided newDistribution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_versioned_distribution_with_http_info(body, catalog_id, record_id, version_id, distribution_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: JSON-LD of the new Distribution which will replace the existing Distribution (required)
        :param str catalog_id: String representing the Catalog ID (required)
        :param str record_id: String representing the VersionedRecord ID (required)
        :param str version_id: String representing the Version ID (required)
        :param str distribution_id: String representing the Distribution ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'catalog_id', 'record_id', 'version_id', 'distribution_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_versioned_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if ('catalog_id' not in params or
                params['catalog_id'] is None):
            raise ValueError("Missing the required parameter `catalog_id` when calling `update_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `update_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `update_versioned_distribution`")  # noqa: E501
        # verify the required parameter 'distribution_id' is set
        if ('distribution_id' not in params or
                params['distribution_id'] is None):
            raise ValueError("Missing the required parameter `distribution_id` when calling `update_versioned_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catalog_id' in params:
            path_params['catalogId'] = params['catalog_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501
        if 'distribution_id' in params:
            path_params['distributionId'] = params['distribution_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/distributions/{distributionId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
